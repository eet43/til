# 지연로딩 사용하기

# 프록시란 ?
실제 객체를 참조하는 껍데기 객체로, 보통 데이터베이스의 접근을 미루기 위해 사용된다.<br><br>
실제 객체를 상속 받아서 만들어지며, 필드, 메소드의 구조는 동일하다.<br><br>
프록시 객체를 호출하면, 프록시 객체는 참조하는 실제 객체를 호출한다.<br><br>

## 프록시 원리
```java
  Member member = em.getReference(Member.class, "id1") //find 가 아닌 getReference 메소드를 실행하면, 프록시 객체가 생성된다.
  member.getName(); // 프록시 객체를 호출하면, 실제 객체를 호출하고, 초기화가 이루어진다.
```
<br><br>
<img width="790" alt="05" src="https://user-images.githubusercontent.com/59008469/170217736-27f9328a-5f0a-4b75-ac67-fca291aeafa3.png">
<br><br>
1. target 객체가 지정이 되지 않았다면, 영속성 컨텍스트에 초기화 요청을 한다.
2. db에서 실제 객체를 가져와 엔티티를 생성한다.
3. 프록시 객체를 실제 객체를 호출한다.
4. 이 과정은 처음 한 번만 이루어진다.

<br><br>
## 프록시 특징
1. 프록시 객체를 초기화 한다고 해서, 프록시 객체가 실제 엔티티 객체가 되는 것은 아니다. `getClass()` 메소드를 통해 확인해보면 Proxy 객체로 나온다.
2. 영속성 컨텍스트에 이미 실제 객체가 존재하면, `getReference` 메소드는 실제 객체를 반환한다.
3. 준영속성 상태일 때에는 초기화를 진행 할 수 없다. <br><br>


# 지연 로딩이란 ?
보통 객체는 다른 객체를 참조하는 변수를 함께 가지고 있다.<br><br>
이런 객체를 조회하는 쿼리를 날리면 JPA 는 자동으로 두 테이블을 조인해서 결과 값을 가져온다.<br><br>
서비스 로직에서 지금은 다른 객체의 정보를 사용하지 않고, this 객체의 정보만 사용할 건데, 굳이 조인해서 가져오지 말고 필요할 때만 조인해서 쿼리를 날릴 수 없을까 ? <br><br>
지연로딩을 사용하자 ! <br><br>

## 지연 로딩의 원리
<img width="881" alt="06" src="https://user-images.githubusercontent.com/59008469/170220276-04fae433-6e7b-4d42-a8d0-59ba95abc9a7.png"> <br><br>
지연 로딩을 설정하면, this 객체인 Member 테이블에 대한 쿼리문을 작성해 보낸다. 그 후 참조하는 객체인 Team 클래스 객체는 프록시 객체로 생성하는 것이다. <br><br>
후에 Team 클래스를 호출하게 되면, 앞에서 설명했듯이 실제 객체를 받아와 호출하는 형식으로 지연로딩이 진행된다. <br><br>
우리는 필요할 때 적절한 쿼리를 작성해 데이터를 가져옴으로서 성능상 효율을 높일 수 있게 된다.<br><br>

## 사용방법
기본적으로 @OneToOne, @ManyToOne 매핑 방식은 기본값이 즉시로딩 => (fetch = FetchType.EAGER) 이기 때문에 `@ManyToOne(fetch = FetchType.LAZY)` 로 바꿔야한다.. <br><br>
@OneToMany, @ManyToMany (실무에서는 사용하지 않는다) 은 기본값이 지연로딩이므로 설정하지 않아도 된다. <br><br>

## 실무 사용법
***무조건 지연로딩을 사용한다.*** N+1 쿼리 문제가 발생할 수 있기 때문<br><br>
즉시로딩이 필요한 경우가 있을 수 있다. (ex 자주 함께 사용되는 경우) 이때는 JPQL 의 `fetch JOIN` 을 사용하자.
